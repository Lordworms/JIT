#include <llvm/ADT/APFloat.h>
#include <llvm/ADT/STLExtras.h>
#include <llvm/IR/BasicBlock.h>
#include <llvm/IR/Constant.h>
#include <llvm/IR/DerivedTypes.h>
#include <llvm/IR/Function.h>
#include <llvm/IR/IRBuilder.h>
#include <llvm/IR/LLVMContext.h>
#include <llvm/IR/Module.h>
#include <llvm/IR/Type.h>
#include <llvm/IR/Verifier.h>

#include <cctype>
#include <cstdio>
#include <iostream>
#include <map>
#include <memory>
#include <string>
#include <utility>
#include <vector>
/*
  llvm usage
*/
using llvm::APFloat;
using llvm::BasicBlock;
using llvm::ConstantFP;
using llvm::errs;
using llvm::Function;
using llvm::FunctionType;
using llvm::IRBuilder;
using llvm::LLVMContext;
using llvm::Module;
using llvm::Type;
using llvm::Value;
/*
  llvm usage
*/

/**
 * Unnamed Namespaces 
They are directly usable in the same program and are used for declaring unique identifiers.
In unnamed namespaces, name of the namespace in not mentioned in the declaration of namespace.
The name of the namespace is uniquely generated by the compiler.
The unnamed namespaces you have created will only be accessible within the file you created it in.
Unnamed namespaces are the replacement for the static declaration of variables.
*/
class ExprAST {
 public:
  virtual ~ExprAST() = default;

  /*
    the codegen method
    Value represent a SSA
  */
  virtual Value *codegen() = 0;
};

class NumberExprAST : public ExprAST {
 public:
  NumberExprAST(double Val) : Val(Val) {}
  Value *codegen() override;

 private:
  double Val;
};

class VariableExprAST : public ExprAST {
 public:
  VariableExprAST(const std::string &name) : Name(name) {}
  Value *codegen() override;

 private:
  std::string Name;
};

class BinaryExprAST : public ExprAST {
 public:
  BinaryExprAST(char Op, std::unique_ptr<ExprAST> LHS,
                std::unique_ptr<ExprAST> RHS)
      : Op(Op), LHS(std::move(LHS)), RHS(std::move(RHS)) {}
  Value *codegen() override;

 private:
  char Op;
  std::unique_ptr<ExprAST> LHS, RHS;
};

class CallExprAST : public ExprAST {
 public:
  CallExprAST(const std::string &Callee,
              std::vector<std::unique_ptr<ExprAST>> Args)
      : Callee(Callee), Args(std::move(Args)) {}
  Value *codegen() override;

 private:
  std::string Callee;
  std::vector<std::unique_ptr<ExprAST>> Args;
};

/*
  represent a Function Prototype
*/
class PrototypeAST {
 public:
  PrototypeAST(const std::string &Name, std::vector<std::string> Args)
      : Name(Name), Args(std::move(Args)) {}
  Function *codegen();
  const std::string &getName() const { return Name; }

 private:
  std::string Name;
  std::vector<std::string> Args;
};

class FunctionAST {
 public:
  FunctionAST(std::unique_ptr<PrototypeAST> Proto,
              std::unique_ptr<ExprAST> Body)
      : Proto(std::move(Proto)), Body(std::move(Body)) {}
  Function *codegen();

 private:
  std::unique_ptr<PrototypeAST> Proto;
  std::unique_ptr<ExprAST> Body;
};

static std::unique_ptr<LLVMContext> TheContext;
static std::unique_ptr<Module> TheModule;
static std::unique_ptr<IRBuilder<>> Builder;
static std::map<std::string, Value *> NamedValues;
std::unique_ptr<ExprAST> LogError(const char *Str);
std::unique_ptr<PrototypeAST> LogErrorP(const char *Str);
Value *LogErrorV(const char *Str);
void InitializeModule();